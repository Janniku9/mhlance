---
import { Icon } from 'astro-icon/components';
import { Icons } from '../../types/Icons';

const SELECT_CLASSES = {
  container: 'relative inline-block',
  trigger:
    'flex items-center justify-between px-4 py-3 min-w-[200px] bg-background-darker rounded-lg cursor-pointer transition-colors hover:bg-primary-light hover:text-background text-text',
  optionsContainer: `
    absolute top-full left-0 right-0 mt-2 
    bg-background-darker rounded-lg overflow-hidden z-50 
    opacity-0 -translate-y-2 pointer-events-none 
    transition-all duration-200 
    data-[open=true]:opacity-100 
    data-[open=true]:translate-y-0 
    data-[open=true]:pointer-events-auto
  `,
  icon: 'transition-transform duration-200 data-[open=true]:rotate-180',
} as const;

interface Props {
  id?: string;
  name?: string;
  defaultValue?: string;
  ariaLabel?: string;
}

const {
  id = 'custom-select',
  name = 'select',
  defaultValue = '',
  ariaLabel = 'Select an option',
} = Astro.props;
---

<div
  class={SELECT_CLASSES.container}
  data-custom-select
  id={id}
  role="combobox"
  aria-haspopup="listbox"
  aria-expanded="false"
  aria-controls={`${id}-options`}
  aria-label={ariaLabel}
>
  <div class={SELECT_CLASSES.trigger} data-select-trigger tabindex="0">
    <span data-selected-text>
      <slot name="selected">Select an option</slot>
    </span>
    <slot name="icon">
      <Icon name={Icons.down} class={SELECT_CLASSES.icon} />
    </slot>
  </div>
  <div
    class={SELECT_CLASSES.optionsContainer}
    data-select-options
    id={`${id}-options`}
    role="listbox"
  >
    <slot />
  </div>
</div>

<script>
  interface SelectOption {
    value: string;
    text: string;
  }

  class CustomSelect {
    private element: HTMLElement;
    private trigger: HTMLElement | null;
    private options: HTMLElement | null;
    private selectedText: HTMLElement | null;
    private isOpen = false;
    private activeOptionIndex = -1;

    constructor(element: HTMLElement) {
      this.element = element;
      this.trigger = element.querySelector('[data-select-trigger]');
      this.options = element.querySelector('[data-select-options]');
      this.selectedText = element.querySelector('[data-selected-text]');

      this.init();
    }

    private init(): void {
      this.setupEventListeners();
      this.setupAccessibility();
    }

    private setupEventListeners(): void {
      // Click handlers
      this.trigger?.addEventListener('click', this.handleTriggerClick.bind(this));

      // Keyboard navigation
      this.element.addEventListener('keydown', this.handleKeydown.bind(this));

      // Close on outside click
      document.addEventListener('click', this.handleOutsideClick.bind(this), { passive: true });

      // Option selection
      this.options?.addEventListener('click', this.handleOptionClick.bind(this));
    }

    private setupAccessibility(): void {
      this.element.setAttribute('aria-expanded', 'false');

      this.options?.querySelectorAll('[data-select-option]').forEach((option, index) => {
        option.setAttribute('role', 'option');
        option.setAttribute('tabindex', '-1');
        option.setAttribute('id', `${this.element.id}-option-${index}`);
      });
    }

    private handleTriggerClick(e: Event): void {
      e.preventDefault();
      this.toggle();
    }

    private handleKeydown(e: KeyboardEvent): void {
      switch (e.key) {
        case 'Enter':
        case ' ':
          e.preventDefault();
          this.isOpen ? this.selectActiveOption() : this.open();
          break;
        case 'Escape':
          this.close();
          break;
        case 'ArrowDown':
          e.preventDefault();
          this.navigateOptions(1);
          break;
        case 'ArrowUp':
          e.preventDefault();
          this.navigateOptions(-1);
          break;
      }
    }

    private handleOutsideClick(e: Event): void {
      if (!this.element.contains(e.target as Node)) {
        this.close();
      }
    }

    private handleOptionClick(e: Event): void {
      const option = (e.target as HTMLElement).closest('[data-select-option]');
      if (option) {
        this.selectOption(option as HTMLElement);
      }
    }

    private navigateOptions(direction: number): void {
      const options = Array.from(this.options?.querySelectorAll('[data-select-option]') || []);
      if (!options.length) return;

      this.activeOptionIndex = Math.max(
        0,
        Math.min(options.length - 1, this.activeOptionIndex + direction)
      );

      const activeOption = options[this.activeOptionIndex] as HTMLElement;
      activeOption.focus();
      this.updateActiveOption(activeOption);
    }

    private selectActiveOption(): void {
      const options = Array.from(this.options?.querySelectorAll('[data-select-option]') || []);
      if (this.activeOptionIndex >= 0 && this.activeOptionIndex < options.length) {
        this.selectOption(options[this.activeOptionIndex] as HTMLElement);
      }
    }

    private updateActiveOption(option: HTMLElement): void {
      this.options?.querySelectorAll('[data-select-option]').forEach((opt) => {
        opt.setAttribute('aria-selected', 'false');
      });
      option.setAttribute('aria-selected', 'true');
    }

    private toggle(): void {
      this.isOpen ? this.close() : this.open();
    }

    private open(): void {
      if (this.isOpen) return;

      this.isOpen = true;
      this.element.setAttribute('aria-expanded', 'true');
      this.options?.setAttribute('data-open', 'true');
      this.trigger?.querySelector('.arrow-icon')?.setAttribute('data-open', 'true');

      // Reset active option index
      this.activeOptionIndex = -1;
    }

    private close(): void {
      if (!this.isOpen) return;

      this.isOpen = false;
      this.element.setAttribute('aria-expanded', 'false');
      this.options?.setAttribute('data-open', 'false');
      this.trigger?.querySelector('.arrow-icon')?.setAttribute('data-open', 'false');
    }

    private selectOption(option: HTMLElement): void {
      const value = option.getAttribute('data-value');
      const text = option.textContent?.trim();

      if (!value || !text) return;

      this.updateSelection({ value, text });
      this.close();
    }

    private updateSelection(selection: SelectOption): void {
      // Update selected state
      this.options?.querySelectorAll('[data-select-option]').forEach((opt) => {
        opt.setAttribute('data-selected', 'false');
        opt.setAttribute('aria-selected', 'false');
      });

      const selectedOption = this.options?.querySelector(`[data-value="${selection.value}"]`);
      if (selectedOption) {
        selectedOption.setAttribute('data-selected', 'true');
        selectedOption.setAttribute('aria-selected', 'true');
      }

      // Update trigger text
      if (this.selectedText) {
        this.selectedText.textContent = selection.text;
      }

      // Dispatch change event
      this.element.dispatchEvent(
        new CustomEvent('select:change', {
          detail: selection,
          bubbles: true,
        })
      );
    }
  }

  // Initialize with requestAnimationFrame for better performance
  const initCustomSelects = () => {
    requestAnimationFrame(() => {
      document.querySelectorAll('[data-custom-select]').forEach((select) => {
        new CustomSelect(select as HTMLElement);
      });
    });
  };

  // Initialize on page load and after view transitions
  initCustomSelects();
  document.addEventListener('astro:after-swap', initCustomSelects);

  // Clean up event listeners when the component is removed
  document.addEventListener('astro:before-swap', () => {
    document.querySelectorAll('[data-custom-select]').forEach((select) => {
      select.replaceWith(select.cloneNode(true));
    });
  });
</script>
